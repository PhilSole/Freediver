const FD = {};
FD.preload = function() {
    console.log('preload');

    this.load.setBaseURL('./assets/');
    this.load.image('water', 'backgrounds/underwater.jpg');
    this.load.image('stop', 'sprites/hand-stop.png');
    this.load.spritesheet('swimmer', 'sprites/swimmer.png', { 
        frameWidth: 55, 
        frameHeight: 32 
    });
}

FD.preloadPause = function() {
    console.log('preload pause');
}
FD.create = function() {
    console.log('create');

    let theScene = this.scene;

    //===========================
    // World
    //===========================
    let worldWidth = 640;
    let worldHeight = 360;

    this.cameras.main.setBounds(-2.5 * worldWidth, 0, 5 * worldWidth, 5 * worldHeight);
    this.matter.world.setBounds(-2.5 * worldWidth, 0, 5 * worldWidth, 5 * worldHeight, 64, true, true, true, true); 
    
    
    //===========================
    // Background
    //===========================
    let background = this.add.image(-2.5 * worldWidth, 0, 'water').setOrigin(0);

    background.displayWidth = 5 * worldWidth;
    background.displayHeight = 5 * worldHeight;


    //===========================
    // Terrain            
    //===========================


    //===========================
    // Player
    //===========================
    // let playerSprite = this.add.sprite(100, 150, 'swimmer');

    // FD.player = this.matter.add.gameObject(playerSprite, {
    //     frictionAir: 0.0027,
    //     density: .046
    // });

    // FD.player.anims.create({
    //     key: 'swimLeft',
    //     frames: this.anims.generateFrameNumbers('swimmer', { start: 0, end: 7 }),
    //     frameRate: 10,
    //     repeat: -1
    // });

    // FD.player.anims.create({
    //     key: 'swimRight',
    //     frames: this.anims.generateFrameNumbers('swimmer', { start: 8, end: 15 }),
    //     frameRate: 10,
    //     repeat: -1
    // });    

    //===========================
    // Other characters
    //===========================

    upper = this.matter.add.rectangle(100, 100, 40, 15, {
        label: 'upper',
        chamfer: 5,
        mass: 40,
        ignoreGravity: true
    });

    lower = this.matter.add.rectangle(80, 100, 40, 15, {
        label: 'lower',
        chamfer: 5,
        mass: 40,
        ignoreGravity: true
    });

    groupBody = this.matter.world.nextGroup(true);

    lower.collisionFilter.group = groupBody;
    upper.collisionFilter.group = groupBody;

    this.matter.add.joint(upper, lower, 0, .1, {
        pointA: { x: -10, y: 0 },
        pointB: { x: 10, y: 0 },
        angularStiffness: .85
    });

    //===========================
    // Physics experiments
    //===========================
    // let circle = this.add.circle(60, 90, 15);

    // FD.circle1 = this.matter.add.gameObject(circle, {
    //     shape: 'circle',
    //     frictionAir: 0.0027,
    //     density: 0.1161
    // });

    //===========================
    // Camera
    //===========================    
    // this.cameras.main.setDeadzone(30, 30);
    // this.cameras.main.startFollow(FD.player, true, 0.05, 0.05); // lerp (linear interpolation for follow)
    this.cameras.main.setZoom(1);

    //===========================
    // Data
    //===========================
    FD.data = this.add.text(15, 15)
            .setText(['Depth: ', 'Pressure: ', 'Lung volume: ', 'Oxygen: '])
            .setScrollFactor(0);
            FD.data.setShadow(1, 1, '#000000', 2);

    
    //===========================
    // Controls
    //===========================
    // this.input.setDefaultCursor('url(assets/input/cursors/blue.cur), pointer');
    this.matter.add.mouseSpring({
        angularStiffness: .5
    });

    // this.input.on('pointerdown', function (pointer) {
    //     console.log('click');
    // }, this);  

    this.input.setPollRate(200); // Fixed and issue where pointer wasn't polled if mouse wasn't moving for a few seconds
    
    let pause = this.add.image(600, 40, 'stop').setScrollFactor(0).setInteractive();

    pause.displayWidth = 40;
    pause.displayHeight = 40;

    pause.on('pointerdown', function () { 
        theScene.pause();
        theScene.run('pauseScene');
    });
         
}

FD.createPause = function() {
    console.log('create pause');
    let theScene = this.scene;

    this.input.on('pointerdown', function (pointer) {
        theScene.pause();
        theScene.run('gameScene');
    }, this);    
}

let buoyancyConstant = 75.5 * 1.025 * .00015;
console.log(buoyancyConstant);

FD.oxygen = 100;
FD.timeStart = 0;
FD.timeElapsed = 0

FD.update = function(time, delta) {

    // let player = FD.player;

    // if(player.body.velocity.x > 0.1) {
    //     player.anims.play('swimRight', true);
    // } else if(player.body.velocity.x < -0.1) {
    //     player.anims.play('swimLeft', true);
    // } else {
    //     player.anims.stop();
    // }

    

    // // Calculate buoyancy force
    // let depth = player.body.position.y/15;
    // let pressure = depth * 1025 * 9.8 + 100000;
    // let pressureRatio = 100000/pressure;
    // let airVolume = 10 * pressureRatio;
    // let buoyancyVariable = airVolume * 1.025 * 0.00015;
    // let buoyancyTotal = buoyancyConstant + buoyancyVariable;

    // // Pointer (swimming) force
    // let pointer = this.input.activePointer;
    // let swimVec = new Phaser.Math.Vector2();

    // if(pointer.isDown) {
    //     console.log(pointer);
    //     let pointerX = pointer.worldX;
    //     let pointerY = pointer.worldY;
    
    //     let playerX = player.body.position.x;
    //     let playerY = player.body.position.y;

    //     swimVec.set(pointerX - playerX, pointerY - playerY);
    //     swimVec.setLength(.0013);

    //     // console.log(swimVec.angle());

    //     player.setRotation(swimVec.angle());
    // }

    // swimVec.add({x:0, y: -buoyancyTotal});

    // // Apply total forces
    // player.applyForce(swimVec);

    // // Calculate remaining oxygen
    // if(FD.timeStart == 0) {
    //     FD.timeStart = time;
    //     console.log('start');
    // } else {
    //     FD.timeElapsed += delta;
    //     FD.oxygen -= FD.timeElapsed/12000000;
    // }


    // FD.data.setText([
    //     'Depth: ' + parseInt(player.body.position.y / 15) + 'm',
    //     'Pressure: ' + (pressure/100000).toFixed(1) + 'BAR',
    //     'Lung volume: ' + airVolume.toFixed(1) + 'L',
    //     'Oxygen: ' + Math.round(FD.oxygen) + '%',
    // ])
} 

// ======================================
// Calculate required gravity value
// ======================================

// var bla = 0;

// if(bla < 1) {
//     console.log('first update: ' + a);
//     console.log(FD.circle1);
//     // FD.game.destroy();
//     bla = 1;
// }

// if(FD.circle1.position.y >= 345) {
//     console.log('last update:' + a);
//     console.log(FD.circle1);
//     FD.game.destroy();
// }

FD.updatePause = function(time, delta) {
    // console.log('updating pause');
}
FD.metre = 15;

FD.gameSceneConfig = {
    key: 'gameScene',
    physics: {
        default: 'matter',
        matter: {
            debug: { // See debug options.js example
                showAngleIndicator: true,
                showCollisions: true,
                showSleeping: true,
                showJoint: true,
            },
            enableSleeping: false, // Performance gain - Bodies that come to rest can sleep and wake. https://github.com/liabru/matter-js/issues/354
            gravity: { 
                y: .15 
            },
            plugins: {
                attractors: true
            },
            constraintIterations: 10
        }
    },
    preload: FD.preload,
    create: FD.create,
    update: FD.update    
}

FD.pauseSceneConfig = {
    key: 'pauseScene',
    preload: FD.preloadPause,
    create: FD.createPause,
    update: FD.updatePause
}

FD.config = {
    type: Phaser.AUTO, // Either WebGL or canvas
    parent: 'gameContainer',
    width: 640,
    height: 360,
    resolution: window.devicePixelRatio,
    backgroundColor: '#c4dedf',
    pixelArt: false, // pixel graphics won't blur when scaling. https://www.html5gamedevs.com/topic/36607-scaling-the-canvas-for-pixel-art/
    scale: {
        // parent: 'yourgamediv',
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        // width: 800,
        // height: 600
    },
    scene: [FD.gameSceneConfig, FD.pauseSceneConfig]
};
function ready(callbackFunc) {
    if (document.readyState !== 'loading') {
        callbackFunc();
    } else {
        document.addEventListener('DOMContentLoaded', callbackFunc);
    }
}

ready(function () {
    console.log('under wayish');

    FD.game = new Phaser.Game(FD.config);

    // FD.game.events.on('step', function(time, delta){
    //     console.log('step: ' + time);
    // });    

    // FD.game.events.on('poststep', function(time, delta){
    //     console.log('poststep: ' + time);
    // });

    // FD.game.events.on('preupdate', function(time, delta){
    //     console.log('preupdate: ' + time);
    // });
    
    // FD.game.events.on('prerender', function(renderer, time, delta){
    //     console.log('prerender: ' + time);
    // });    
});